#' Translate survival design bounds to exact binomial bounds
#'
#' @param x an object of class \code{gsSurv}; 
#' i.e. an object generated by the \code{gsSurv()} function.
#'
#' @seealso [gsBinomialExact]
#' @return An object of class \code{gsBinomialExact}
#' @export
#'
#' @examples
#' The following code derives the group sequential design using the method of Lachin and Foulkes.
#' 
#' x <- gsSurv(
#'   k = 3,                 # 3 analyses
#'   test.type = 4,         # Non-binding futility bound 1 (no futility bound) and 4 are allowable
#'   alpha = .025,          # 1-sided Type I error
#'   beta = .1,             # Type II error (1 - power)
#'   timing = c(0.45, 0.7), # Proportion of final planned events at interims
#'   sfu = sfHSD,          # Efficacy spending function
#'   sfupar = -4,           # Parameter for efficacy spending function
#'   sfl = sfLDOF,          # Futility spending function; not needed for test.type = 1
#'   sflpar = 0,            # Parameter for futility spending function
#'   lambdaC = .001,        # Exponential failure rate
#'   hr = 0.3,              # Assumed proportional hazard ratio (1 - vaccine efficacy = 1 - VE)
#'   hr0 = 0.7,             # Null hypothesis VE
#'   eta = 5e-04,           # Exponential dropout rate
#'   gamma = 10,            # Piecewise exponential enrollment rates
#'   R = 16,                # Time period durations for enrollment rates in gamma
#'   T = 24,                # Planned trial duration
#'   minfup = 8,            # Planned minimum follow-up
#'   ratio = 3              # Randomization ratio (experimental:contro)
#' )
#' # Convert bounds to exact binomial bounds
#' toBinomialExact(x)
toBinomialExact <- function(x){
  if (class(x)[1] != "gsSurv") stop("toBinomialExact must have class gsSurv as input")
  if (x$test.type != 1 && x$test.type != 4) stop("toBinomialExact input test.type must be 1 or 4")
# Round interim sample size (or events for gsSurv object)
  xx <- toInteger(x)
  k <- xx$k
  counts <- xx$n.I
  
# Translate vaccine efficacy to exact binomial probabilities
  
  p0 <- x$hr0 * x$ratio / (1 + x$hr0 * x$ratio)
  p1 <- x$hr  * x$ratio / (1 + x$hr  * x$ratio)
  
  # Lower bound probabilities are for efficacy and Type I error should be controlled under p0
  a <- qbinom(p = pnorm(-x$upper$bound), size = counts, prob = p0) - 1
  atem <- a
  alpha_spend <- x$upper$sf(alpha = x$alpha, t = xx$timing, param = x$upper$param)$spend
  if (x$test.type != 1){  
     # Upper bound probabilities are for futility
     # Compute nominal p-values under H0 for futility and corresponding inverse binomial under H1
     b <- qbinom(p = pnorm(x$lower$bound), size = counts, prob = p1, lower.tail = TRUE)
     btem <- b
     # Compute target beta-spending
     beta_spend <- xx$lower$sf(alpha = xx$beta, t = xx$timing, param = xx$lower$param)$spend
  }else{ 
    b <- counts + 1 # test.type = 1 means no futility bound
    nbupperprob <- 0
  }
  for(j in 1:x$k){
    # non-binding bound assumed
    # compute spending through analysis j
    # NOTE: cannnot call gsBinomialExact with k == 1, so make it at least 2
    nblowerprob <- sum(gsBinomialExact(k = max(j, 2), theta = p0, n.I = counts[1:max(j, 2)], a = atem[1:max(j, 2)], b = counts[1:max(j, 2)] + 1)$lower$prob[1:j])
    atem <- a
    btem <- b
    while(nblowerprob < alpha_spend[j]){
      a[j] <- atem[j]
      atem[j] <- atem[j] + 1
      nblowerprob <- sum(gsBinomialExact(k = max(j, 2), theta = p0, n.I = counts[1:max(j, 2)], a = atem[1:max(j, 2)], b = counts[1:max(j, 2)] + 1)$lower$prob[1:j])
    }
    nblowerprob <- sum(gsBinomialExact(k = max(j, 2), theta = p0, n.I = counts[1:max(j, 2)], a = a[1:max(j, 2)], b = counts[1:max(j, 2)] + 1)$lower$prob[1:j])
    while(nblowerprob > alpha_spend[j]){
      a[j] <- atem[j]
      atem[j] <- atem[j] - 1
      nblowerprob <- sum(gsBinomialExact(k = max(j, 2), theta = p0, n.I = counts[1:max(j, 2)], a = atem[1:max(j, 2)], b = counts[1:max(j, 2)] + 1)$lower$prob[1:j])
    }
    # beta-spending, if needed
    if(x$test.type == 4){
      upperprob <- sum(gsBinomialExact(k = max(j, 2), theta = p1, n.I = counts[1:max(j, 2)], a = a[1:max(j, 2)], b = b[1:max(j, 2)])$upper$prob[1:j])
      while(upperprob < beta_spend[j]){
        b[j] <- btem[j]
        if (btem[j] == a[j] + 1) break # Cannot make a and b bounds the same
        btem[j] <- btem[j] - 1
        upperprob <- sum(gsBinomialExact(k = max(j, 2), theta = p1, n.I = counts[1:max(j, 2)], a = a[1:max(j, 2)], b = btem[1:max(j, 2)])$upper$prob[1:j])
      }
      upperprob <- sum(gsBinomialExact(k = max(j, 2), theta = p1, n.I = counts[1:max(j, 2)], a = a[1:max(j, 2)], b = b[1:max(j, 2)])$upper$prob[1:j])
      while(upperprob > beta_spend[j]){
        b[j] <- btem[j]
        btem[j] <- btem[j] + 1
        upperprob <- sum(gsBinomialExact(k = max(j, 2), theta = p1, n.I = counts[1:max(j, 2)], a = a[1:max(j, 2)], b = btem[1:max(j, 2)])$upper$prob[1:j])
      }
    }
  }
  xxxx <- gsBinomialExact(k = k, theta = c(p0, p1), n.I = counts, a = a, b = b)
  return(xxxx)
}
